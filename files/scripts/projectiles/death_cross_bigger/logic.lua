dofile_once("data/scripts/lib/utilities.lua")
dofile_once("mods/purgatory/files/scripts/lib/utilities.lua")

--HELPER FUNCTIONS

--Takes the damage types from ProjectileComponent's object "damage_by_type" and turns them into a single string that can be written to a variable storage component
local function stringifyDamageTypesTable(dmg_by_type_table)
    local output_string = ""

    for damage_type, amount_of_damage in pairs(dmg_by_type_table) do
        output_string = output_string .. damage_type .. "=" .. amount_of_damage .. ","
    end

    output_string = string.sub(output_string, 1, -2)

    return output_string
end

--Takes a string generated by stringifyDamageTypesTable(dmg_by_type_table) and turns it back into a string indexed table akin to what you would get from ComponentObjectGetMembers(comp, obj)
local function destringifyDamageTypesString(dmg_by_type_string)
    local output_table = {}
    local list = splitStringOnCharIntoTable(dmg_by_type_string, ",")

    --list should now be something like { "ice=0", "electricity=0", ... }
    for i, v in ipairs(list) do
        local param_and_value = splitStringOnCharIntoTable(v, "=") --param_and_value should be like {"ice","0"}
        output_table[param_and_value[1]] = param_and_value[2]
    end

    return output_table
end

--[[
    Functions above are used to transmute data between these two forms.
    This is done so I can store the table's values into a single variable storage comp

    data = {
        "ice" = "0"
        "electricity" = "0"
        "radioactive" = "0"
        "slice" = "0"
        "curse" = "0"
        "overeating" = "0"
        "projectile" = "0"
        "healing" = "0"
        "physics_hit" = "0"
        "explosion" = "0"
        "poison" = "0"
        "melee" = "0"
        "drill" = "0"
        "fire" = "0.4"
    }

    data = "ice=0,electricity=0,radioactive=0,slice=0,curse=0,overeating=0,projectile=0,healing=0,physics_hit=0,explosion=0,poison=0,melee=0,drill=0,fire=0.4"
]]
--Omega Death Cross Custom Logic BEGIN
local entity_id = GetUpdatedEntityID()
local x, y = EntityGetTransform(entity_id)

--Variable Storage Component Values
local power_level = variableStorageGetValue(entity_id, "FLOAT", "power_level")
local projectiles_absorbed = variableStorageGetValue(entity_id, "INT", "projectiles_absorbed")
local stored_damage = variableStorageGetValue(entity_id, "FLOAT", "stored_damage")
local stored_damage_by_type_string = variableStorageGetValue(entity_id, "STRING", "stored_damage_by_type")
local stored_damage_by_type_table = destringifyDamageTypesString(stored_damage_by_type_string)

--Power Level Calculation
power_level = math.min(math.sqrt(projectiles_absorbed / 20), 10)
variableStorageSetValue(entity_id, "FLOAT", "power_level", power_level)

--[[
With this "power curve":
#Projectiles Eaten      Power Level
0                       0
20                       1
80                       2
180                       3
320                       4
500                       5
720                       6
980                       7
1280                       8
1620                       9
2000                       10

Capped at 10x
]]
--Gravitational Distance and Strength Calculation
--Gravitational Distance and Strength Calculation
local scaling_factor = 2 * (power_level + 1) / 10
local distance_full = 256 * scaling_factor
local gravity_coeff = 256 * scaling_factor
local absorbtion_distance = 16 * scaling_factor

--Projectile Gravity and Absorbtion
local projectiles = EntityGetWithTag("projectile")
if (#projectiles > 0) then
    for i, projectile_id in ipairs(projectiles) do
        if (not EntityHasTag(projectile_id, "death_cross_bigger")) then
            local px, py = EntityGetTransform(projectile_id)

            local distance = math.abs(x - px) + math.abs(y - py)

            --Gravitational
            if (distance < distance_full * 1.25) and (entity_id ~= projectile_id) then
                distance = math.sqrt((x - px) ^ 2 + (y - py) ^ 2)
                local direction = 0 - math.atan2((y - py), (x - px))

                if (distance < distance_full) then
                    local velocitycomponents = EntityGetComponent(projectile_id, "VelocityComponent")

                    local gravity_percent = (distance_full - distance) / distance_full

                    if (velocitycomponents ~= nil) then
                        edit_component(
                            projectile_id,
                            "VelocityComponent",
                            function(comp, vars)
                                local vel_x, vel_y = ComponentGetValueVector2(comp, "mVelocity")

                                local offset_x = math.cos(direction) * (gravity_coeff * gravity_percent)
                                local offset_y = 0 - math.sin(direction) * (gravity_coeff * gravity_percent)

                                vel_x = vel_x + offset_x
                                vel_y = vel_y + offset_y

                                ComponentSetValueVector2(comp, "mVelocity", vel_x, vel_y)
                            end
                        )
                    end
                end
            end

            --Absorbing Projectiles
            if (distance < absorbtion_distance) then
                --Get Projectile Comp
                local projectile_comp = EntityGetFirstComponentIncludingDisabled(projectile_id, "ProjectileComponent")

                --Get Damage Value
                local damage = ComponentGetValue2(projectile_comp, "damage")

                --If damage > 0, add it to stored_damage
                if damage > 0 then
                    stored_damage = stored_damage + damage
                    variableStorageSetValue(entity_id, "FLOAT", "stored_damage", stored_damage)
                end

                --Damage By Types
                local dmg_by_type_members = ComponentObjectGetMembers(projectile_comp, "damage_by_type")

                --For each damage by type
                local damage_by_types_have_change = false --tracking var to see if I need to update the storage with new values
                for damage_type, damage_amount in pairs(dmg_by_type_members) do
                    --if damage_amount ~= 0, add it to stored damage type
                    if tonumber(damage_amount) ~= 0 then
                        damage_by_types_have_change = true
                        stored_damage_by_type_table[damage_type] = tostring(tonumber(stored_damage_by_type_table[damage_type]) + tonumber(damage_amount))
                    end
                end

                if damage_by_types_have_change then
                    stored_damage_by_type_string = stringifyDamageTypesTable(stored_damage_by_type_table)
                    variableStorageSetValue(entity_id, "STRING", "stored_damage_by_type", stored_damage_by_type_string)
                end

                --Increment Projectiles Absorbed
                projectiles_absorbed = projectiles_absorbed + 1
                variableStorageSetValue(entity_id, "INT", "projectiles_absorbed", projectiles_absorbed)

                --Destroy Projectile
                EntityKill(projectile_id)
            end
        end
    end
end

--Calculate and Update Particles
local power_level_floor = math.floor(power_level)
local vel_min = -(100 + 5 * power_level_floor)
local vel_max = 100 + 5 * power_level_floor
local lifetime_min = 0.6 + 0.1 * power_level_floor
local lifetime_max = 3.0 + 0.5 * power_level_floor
local x_pos_offset_min = -(5 + 1 * power_level_floor)
local x_pos_offset_max = 5 + 1 * power_level_floor
local y_pos_offset_min = -(5 + 1 * power_level_floor)
local y_pos_offset_max = 5 + 1 * power_level_floor
local count_min = 5 + 1 * power_level_floor
local count_max = 10 + 2 * power_level_floor

--Particle Emitter Comps
local particle_emitter_comps = EntityGetComponent(entity_id, "ParticleEmitterComponent")

--Update Values

--First particle emitter is horizontal (if i = 1 then horizonal)
--Second particle emitter is vertical
for i, comp in ipairs(particle_emitter_comps) do
    --Horizontal Particles
    if (i == 1) then
        ComponentSetValue2(comp, "x_vel_min", vel_min)
        ComponentSetValue2(comp, "x_vel_max", vel_max)
        ComponentSetValue2(comp, "y_vel_min", 0)
        ComponentSetValue2(comp, "y_vel_max", 0)
    end

    --Vertical Particles
    if (i == 2) then
        ComponentSetValue2(comp, "x_vel_min", 0)
        ComponentSetValue2(comp, "x_vel_max", 0)
        ComponentSetValue2(comp, "y_vel_min", vel_min)
        ComponentSetValue2(comp, "y_vel_max", vel_max)
    end

    --Shared by vertical and horizontal particles
    ComponentSetValue2(comp, "lifetime_min", lifetime_min)
    ComponentSetValue2(comp, "lifetime_max", lifetime_max)
    ComponentSetValue2(comp, "x_pos_offset_min", x_pos_offset_min)
    ComponentSetValue2(comp, "x_pos_offset_max", x_pos_offset_max)
    ComponentSetValue2(comp, "y_pos_offset_min", y_pos_offset_min)
    ComponentSetValue2(comp, "y_pos_offset_max", y_pos_offset_max)
    ComponentSetValue2(comp, "count_min", count_min)
    ComponentSetValue2(comp, "count_max", count_max)
end
